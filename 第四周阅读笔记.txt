第一个链接：
1.语法错误：语法错误（也称为解析错误）

2.异常：在执行期间检测到的错误称为异常，并且不是无条件致命的
作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常不一定是这样（尽管它是一个有用的约定）。标准异常名称是内置标识符（不是保留关键字）。
错误消息的前一部分以堆栈回溯的形式显示发生异常的上下文。通常它包含列出源代码行的堆栈回溯; 但是，它不会显示从标准输入读取的行。
内置异常列出了内置异常及其含义。


3.处理异常：通过引发KeyboardInterrupt异常来发出用户生成的中断信号。
该try声明的工作原理如下：
首先，执行try子句（try和 except关键字之间的语句）。
如果没有发生异常，则跳过except子句并try完成语句的执行 。
如果在执行try子句期间发生异常，则跳过该子句的其余部分。然后，如果其类型匹配在except关键字后面命名的异常 ，则执行except子句，然后在try语句之后继续执行。
如果发生的异常与except子句中指定的异常不匹配，则将其传递给外部try语句; 如果没有找到处理程序，则它是一个未处理的异常，执行将停止并显示如上所示的消息。

一个try语句可能有不止一个，除了子句，分别指定处理不同的异常。最多将执行一个处理程序。处理程序仅处理相应try子句中发生的异常，而不处理同一try语句的其他处理程序中的异常。except子句可以将多个异常命名为带括号的元组
该try... except语句有一个可选的else子句，其中，如果存在的话，必须遵循所有的条款除外。如果try子句不引发异常，则对于必须执行的代码很有用。

except子句可以在异常名称后面指定一个变量。该变量绑定到存储参数的异常实例 instance.args。为方便起见，异常实例定义 __str__()了参数可以直接打印而无需引用.args。也可以在提升之前首先实例化异常，并根据需要向其添加任何属性。

异常处理程序不仅处理异常（如果它们立即出现在try子句中），而且还发生在try子句中调用（甚至间接）的函数内部。

最后一个except子句可以省略异常名称，以用作通配符。请谨慎使用，因为以这种方式很容易掩盖真正的编程错误！它还可以用于打印错误消息，然后重新引发异常（允许调用者也处理异常）


else：发生异常时，它可能具有关联值，也称为异常参数。参数的存在和类型取决于异常类型。


提高异常
该raise语句允许程序员强制发生指定的异常
唯一的参数raise表示要引发的异常。这必须是异常实例或异常类（派生自的类Exception）。如果传递了一个异常类，它将通过调用没有参数的构造函数来隐式实例化



用户定义的异常
程序可以通过创建新的异常类来命名它们自己的异常。通常应Exception直接或间接地从类中派生异常。
可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类
大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名

定义清理动作：一个finally子句在离开之前一直执行try 的语句，是否已经发生也不例外。当try子句中发生异常且未被except子句处理 （或者它已经发生在except或 else子句中）时，在finally子句执行后重新引发它
该finally子句在任何情况下都会执行。
在实际应用程序中，该finally子句对于释放外部资源（例如文件或网络连接）非常有用，无论资源的使用是否成功。

该with语句允许以一种方式使用文件等对象，以确保始终及时正确地清理它们。预定义的清理操作







第二个链接：

在软件开发中，调试是查找并解决阻止软件正常运行的问题的过程。

if __name__ == '__main__':
Python调试器为Python程序提供调试环境。它支持设置条件断点，一次一行地逐步执行源代码，堆栈检查等。


Python调试器作为标准Python发行版的一部分，作为一个名为的模块pdb。调试器也是可扩展的，并被定义为类Pdb。



$python -m pdb looping.py
该-m命令行标志将导入任何Python模块，为您和运行它作为脚本。在这种情况下，我们正在导入并运行pdb模块，我们将其传递给命令，如上所示。

Output
> /Users/sammy/looping.py(1)<module>()
-> num_list = [500, 600, 700]
(Pdb) 
在输出中，第一行包含当前模块名称（如图所示<module>）和目录路径，以及后面的打印行号（在这种情况下是它1，但如果有注释或其他非可执行行，则可能是更高的数字）。第二行显示了此处执行的当前源代码行，pdb为调试提供了交互式控制台。您可以使用该命令help了解其命令，并了解有关特定命令的更多信息。请注意，控制台与Python交互式shell不同。help commandpdb

Python调试器将在程序结束时自动重新启动。每当您想要离开pdb控制台时，请键入命令quit或exit。如果要在程序中的任何位置显式重新启动程序，可以使用该命令执行此操作run。

1：使用调试器移动程序：
在shell中，我们可以键入命令list以获取当前行的上下文。
当前行用字符表示->
在这里，我们要求使用该命令显示第3-7行list 3, 7。

要逐行浏览程序，我们可以使用step或next
step和next之间的区别是step在被调用的函数内停止，而next执行被调用的函数只停在当前函数的下一行。

step一旦它到达函数的运行，该命令将遍历循环，显示循环正在做什么，因为它将首先打印一个数字，print(number)然后通过打印字母print(letter)，返回数字等

next相反，该命令将执行整个功能，而不显示逐步过程。让我们用exit命令退出当前会话，然后再次启动调试器


在浏览代码时，您可能希望检查传递给变量的值，您可以使用该pp命令执行该操作，该命令将使用pprint模块精确打印表达式的值：

(Pdb) pp num_list
[500, 600, 700]
(Pdb) 
大多数命令pdb都有较短的别名。因为step那个简短的形式是s，而且就是next这样n。该help命令将列出可用的别名。您也可以通过ENTER在提示符下按键调用您调用的最后一个命令。

2:断点：
通过使用该break命令设置断点，您将运行该程序直到指定的断点。

插入断点时，调试器会为其分配一个数字。分配给断点的数字是以数字1开头的连续整数，您可以在使用断点时参考这些数字。
键入clear然后y删除所有当前断点
要查看当前设置为运行的断点列表，请使用break不带任何参数的命令。
我们还可以使用命令disable和断点编号禁用断点。在此会话中，我们添加另一个断点，然后禁用第一个断点



要启用断点，请使用该enable命令，并完全删除断点，请使用以下clear命令：

(Pdb) enable 1
Enabled breakpoint 1 at /Users/sammy/looping.py:7
(Pdb) clear 2
Deleted breakpoint 2 at /Users/sammy/looping.py:11
(Pdb) 

断点pdb为您提供了很多控制。一些额外的功能包括在程序的当前迭代期间使用ignore命令忽略断点（如ignore 1），
使用命令触发在断点处发生的操作commands（如command 1），
并创建在程序执行第一次命中时自动清除的临时断点使用命令的点tbreak（例如，对于第3行的临时中断，您可以键入tbreak 3）。

3:集成pdb到程序中：
您可以通过导入pdb模块并在要开始会话的行上方添加pdb函数来触发调试会话pdb.set_trace()。

通过将调试器添加到代码中，您无需以特殊方式启动程序或记住设置断点。

导入pdb模块并运行该pdb.set_trace()函数可以像往常一样启动程序并通过执行运行调试器。


修改程序执行流程：
Python调试器允许您使用该jump命令在运行时更改程序的流程。这允许您向前跳过以防止某些代码运行，或者可以让您向后跳转以再次运行代码。

调试器会阻止某些跳转，尤其是在跳入和跳出某些未定义的流控制语句时。例如，在定义参数之前不能跳转到函数，并且不能跳到try:except语句的中间。你也不能跳出一个finally街区。

jump使用Python调试器的语句允许您在调试程序时更改执行流程，以查看是否可以将流控制修改为不同的目的，或者更好地了解代码中出现的问题。

常用pdb命令表
下面是一个有用的pdb命令表以及使用Python调试器时要记住的简短表单。

命令	简写	它能做什么
args	a	打印当前函数的参数列表
break	b	在程序执行中创建断点（需要参数）
continue	c 要么 cont	继续执行程序
help	h	提供指定命令的列表或帮助
jump	j	设置要执行的下一行
list	l	在当前行周围打印源代码
next	n	继续执行，直到达到当前函数的下一行或返回
step	s	执行当前行，在第一个可能的场合停止
pp	pp	漂亮打印表达式的值
quit and exit	q	中止该计划
return	r	继续执行，直到当前函数返回









第三个链接：
列表理解包括以下部分：
输入序列。
表示输入序列成员的变量。
一个可选的谓词表达式。
输出表达式，用于从输入序列的成员生成满足谓词的输出列表的元素。


迭代器部分遍历输入序列a_list的每个成员e。
谓词检查成员是否为整数。
如果成员是整数，则将其传递给输出表达式，求平方，以成为输出列表的成员。

一次使用zip()和处理两个或多个元素

os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。
endsWith() 方法用于测试字符串是否以指定的后缀结束。
os.path.join：就是获取当前目录，并组合成新目录
Python splitlines() 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。
os.path.dirname(__file__)返回脚本的路径
os.makedirs(d)：创建目录
 os.path.exists（d）：是否存在d目录
Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。
shutil.rmtree() 递归地删除文件
group（）用来提取分组截获的字符串，（）用来分组

设置理解
集合理解允许使用与列表推导相同的原理构建集合，唯一的区别是结果序列是一个集合。
请注意表示集合的新语法。成员用大括号括起来。
{ name[0].upper() + name[1:].lower() for name in names if len(name) > 1 }


字典理解：
典目前区分大写和小写字符。
mcase = {'a':10, 'b': 34, 'A': 7, 'Z':3}

mcase_frequency = { k.lower() : mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys() }

# mcase_frequency == {'a': 17, 'z': 3, 'b': 34}





第四个链接：
类：类提供了将数据和功能捆绑在一起的方法。创建新类会创建一种新类型的对象，从而允许创建该类型的新实例。每个类实例都可以附加属性以维护其状态。类实例还可以具有用于修改其状态的方法（由其类定义）。
Python类提供面向对象编程的所有标准功能：类继承机制允许多个基类，派生类可以覆盖其基类或类的任何方法，并且方法可以调用具有相同名称的基类的方法。对象可以包含任意数量和种类的数据。与模块一样，类依赖于Python的动态特性：它们是在运行时创建的，并且可以在创建后进一步修改。

一个关于名称和对象的词：
对象具有个性，多个名称（在多个范围内）可以绑定到同一个对象。这在其他语言中称为别名
别名对涉及可变对象（如列表，字典和大多数其他类型）的Python代码的语义可能会产生惊人的影响。这通常用于程序的好处，因为别名在某些方面表现得像指针


Python范围和命名空间：
一个命名空间是从名字到对象的映射。大多数名称空间当前都是作为Python词典实现的，但通常不会以任何方式显示（性能除外），并且它可能在将来发生变化。
命名空间的示例是：内置名称集（包含诸如abs()和内置异常名称之类的函数）; 模块中的全局名称; 和函数调用中的本地名称。在某种意义上，对象的属性集也形成了命名空间。
关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系; 如，两个不同的模块都可以定义函数maximize而不会产生混淆 - 模块的用户必须在其前面加上模块名称。


顺便说一句，我对word 后面的任何名称使用word 属性 - 例如，在表达式中z.real，real是对象的属性 z。严格地说，对模块中名称的引用是属性引用：在表达式中modname.funcname，modname是模块对象并且funcname是它的属性。在这种情况下，模块的属性和模块中定义的全局名称之间恰好有一个直接的映射：它们共享相同的命名空间！ [1]

属性可以是只读的或可写的。在后一种情况下，可以分配属性。模块属性是可写的：你可以写 。可写属性也可以使用语句删除 。



命名空间在不同时刻创建，具有不同的生命周期。包含内置名称的命名空间是在Python解释器启动时创建的，并且永远不会被删除。读入模块定义时会创建模块的全局命名空间; 通常，模块命名空间也会持续到解释器退出。由解释程序的顶级调用执行的语句（从脚本文件读取或交互式读取）被视为调用模块的一部分__main__，因此它们具有自己的全局命名空间。（内置名称实际上也存在于模块中;这称为builtins。）

函数的本地命名空间在调用函数时创建，并在函数返回或引发函数内未处理的异常时删除。

一个命名空间是可直接访问的文本区域。这里的“可直接访问”意味着对名称的非限定引用会尝试在命名空间中查找名称。
其名称空间可以直接访问：

最先搜索的最内部范围包含本地名称
从最近的封闭范围开始搜索的任何封闭函数的范围包含非本地名称，也包括非全局名称
倒数第二个范围包含当前模块的全局名称
最外面的范围（最后搜索）是包含内置名称的命名空间

ython的一个特殊之处在于 - 如果没有global语句生效 - 对名称的赋值总是进入最内层范围。分配不复制数据 - 它们只是将名称绑定到对象。删除也是如此：该语句删除了本地范围引用的命名空间的绑定。
实际上，引入新名称的所有操作都使用本地范围：特别是，语句和函数定义绑定本地范围中的模块或函数名称。del xximport

如果名称声明为全局，则所有引用和赋值将直接转到包含模块全局名称的中间作用域。要重新绑定在最内层范围之外找到的变量，nonlocal可以使用该语句; 如果没有声明为非本地变量，那些变量是只读的（尝试写入这样的变量只会在最里面的范围内创建一个新的局部变量，保持同名的外部变量不变）。

该global陈述可用于表明特定变量存在于全球范围内，并应在那里反弹; 该 nonlocal陈述表明特定变量存在于封闭范围内，应该在那里反弹。

类定义语法
最简单的类定义形式如下所示：

class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
类定义，如函数定义（def语句）必须在它们产生任何影响之前执行。（您可以想象将类定义放在if语句的分支中，或者放在函数内部。）

输入类定义时，会创建一个新的命名空间，并将其用作本地范围 - 因此，对局部变量的所有赋值都将进入此新命名空间。特别是，函数定义在此处绑定新函数的名称。


对象：
类对象支持两种操作：属性引用和实例化。
属性引用使用Python中所有属性引用使用的标准语法：obj.name。有效的属性名称是创建类对象时类的命名空间中的所有名称。

lass MyClass:
    """A simple example class"""
    i = 12345

    def f(self):
        return 'hello world'
然后MyClass.i和MyClass.f是有效的属性的引用，分别返回一个整数和一个功能对象。也可以为类属性分配，因此您可以MyClass.i通过赋值更改值。 __doc__也是一个有效的属性，返回属于该类的docstring : ."A simple example class"


类实例化使用函数表示法。只是假装类对象是一个无参数函数，它返回一个新的类实例。例如（假设上述类）：

x = MyClass()
创建类的新实例，并将此对象分配给局部变量x。


实例化操作（“调用”类对象）创建一个空对象。许多类喜欢创建具有针对特定初始状态定制的实例的对象。因此，类可以定义一个名为的特殊方法 __init__()


实例对象：
实例对象理解的唯一操作是属性引用。有两种有效的属性名称，数据属性和方法。



方法对象：
方法的特殊之处在于实例对象作为函数的第一个参数传递。
在我们的示例中，调用x.f()完全等同于MyClass.f(x)。
通常，使用n个参数列表调用方法等效于使用通过在第一个参数之前插入方法的实例对象而创建的参数列表来调用相应的函数。


类和实例变量：
一般来说，实例变量是针对每个实例唯一的数据，而类变量是针对类的所有实例共享的属性和方法


随机备注：

数据属性覆盖具有相同名称的方法属性; 为了避免可能导致大型程序中难以发现的错误的意外名称冲突，使用某种最小化冲突机会的约定是明智的。
可能的约定包括大写方法名称，使用小的唯一字符串（可能只是下划线）为数据属性名称加前缀，或者使用动词作为数据属性的方法和名词。

请注意，客户端可以将自己的数据属性添加到实例对象，而不会影响方法的有效性，只要避免名称冲突 - 同样，命名约定可以在这里节省很多麻烦。
每个值都是一个对象，因此有一个类（也称为其类型）。它存储为object.__class__。


继承：
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
名称BaseClassName必须在含有派生类定义中的范围来限定。代替基类名称，也允许使用其他任意表达式。
这用于解析属性引用：如果在类中找不到请求的属性，则搜索继续查找基类。如果基类本身是从其他类派生的，则递归应用此规则。

派生类可以覆盖其基类的方法。因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一个方法的基类方法最终可能会调用覆盖它的派生类的方法。

Python有两个内置函数可以继承：
Use isinstance() to check an instance’s type: isinstance(obj, int) will be True only if obj.__class__ is int or some class derived from int.
Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int. However, issubclass(float, int) is False since float is not a subclass of int.



多重继承：
Python也支持多重继承的形式。具有多个基类的类定义如下所示：

class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
在大多数情况下，在最简单的情况下，您可以将从父类继承的属性的搜索视为深度优先，从左到右，而不是在层次结构中存在重叠的同一类中搜索两次。
因此，如果没有找到属性，则在DerivedClassName其中搜索Base1，然后（递归地）搜索它Base1，如果在那里找不到，则搜索它Base2，依此类推。

事实上，它稍微复杂一些; 方法解析顺序动态变化以支持协作调用super()。

动态排序是必要的，因为所有多重继承的情况都表现出一个或多个菱形关系（其中至少有一个父类可以通过最底层的多个路径访问）。


为了防止基类被多次访问，动态算法将搜索顺序线性化，以保留每个类中指定的从左到右的顺序，只调用每个父类一次，这是单调的（意思是一个类可以被子类化，而不会影响其父级的优先顺序）。


私人变量：
以下划线（例如_spam）为前缀的名称应被视为API的非公共部分（无论是函数，方法还是数据成员）。

名称修改有助于让子类覆盖方法而不破坏类内方法调用。

请注意，代码传递给exec()或eval()不将调用类的类名视为当前类; 这类似于global语句的效果，其效果同样限于字节编译在一起的代码。

赔率和结束：
有时，使用类似于Pascal“record”或C“struct”的数据类型是有用的，将一些命名数据项捆绑在一起。一个空的类定义可以很好地完成

实例方法对象也具有属性：m.__self__是具有该方法的实例对象m()，并且m.__func__是与该方法对应的函数对象。



迭代器：
到目前为止，您可能已经注意到大多数容器对象都可以使用for语句循环，这种访问方式清晰，简洁，方便。
迭代器的使用遍及并统一了Python。在幕后，for语句调用iter()容器对象。
该函数返回一个迭代器对象，该对象定义__next__()一次访问容器中元素的方法。当没有更多元素时， __next__()引发一个StopIteration异常，告诉 for循环终止。
您可以__next__()使用next()内置函数调用该方法; 

Generator是一个用于创建迭代器的简单而强大的工具。它们像常规函数一样编写，但yield只要他们想要返回数据就使用该语句。每次next()调用它时，生成器从它停止的地方恢复（它记住所有数据值和上次执行的语句）。
另一个关键特性是在调用之间自动保存局部变量和执行状态。
除了自动创建方法和保存程序状态外，当生成器终止时，它们会自动引发StopIteration。


生成器表达式：
一些简单的生成器可以使用类似于列表推导的语法简洁地编码为表达式，但使用括号而不是方括号。
这些表达式适用于通过封闭函数立即使用生成器的情况。
生成器表达式比完整的生成器定义更紧凑但功能更少，并且往往比等效列表推导更具内存友好性。


除了一件事，模块对象具有一个秘密的只读属性__dict__，该属性 返回用于实现模块命名空间的字典; 
名称__dict__是属性，但不是全局名称。显然，使用它违反了命名空间实现的抽象，并且应该仅限于事后调试器之类的东西。








第五个链接：
魔术方法：么是魔术方法？它们是面向对象Python中的一切。它们是您可以定义的特殊方法，可以为您的类添加“魔力”。它们总是被双下划线（例如__init__或__lt__）包围。它们的记录也不像它们需要的那样好。Python的所有神奇方法都出现在Python文档的同一部分中，但它们分散在各处，并且只是松散组织。
建设和初始化：每个人都知道最基本的魔术方法__init__。这是我们定义对象初始化行为的方式。


__new__(cls, [...)
__new__是第一个在对象的实例化中调用的方法。它接受类，然后传递任何其他参数__init__。__new__很少使用它，但它确实有其用途，特别是在子类化像元组或字符串这样的不可变类型时。我不想详细介绍__new__它，因为它不太有用，但它在Python文档中有详细介绍。
__init__(self, [...)
该类的初始化程序。无论主要构造函数被调用，它都会被传递（例如，如果我们调用x = SomeClass(10, 'foo')，__init__将被传递10并'foo'作为参数。__init__几乎普遍用于Python类定义。
__del__(self)
如果__new__和__init__形成对象的构造函数，__del__则是析构函数。它没有实现语句的行为del x（因此代码不会转换为x.__del__()）。相反，它定义了对象何时被垃圾收集的行为。对于可能需要在删除时进行额外清理的对象（如套接字或文件对象）非常有用。但要小心，因为__del__如果对象在解释器退出时仍处于活动状态时无法保证将被执行，因此__del__无法替代良好的编码实践（例如，在完成连接时始终关闭连接事实上，__del__由于它被称之为不稳定的环境，几乎不应该被使用;谨慎使用它！


使运算符适用用自定义类：
使用Python魔术方法的最大优势之一是它们提供了一种简单的方法来使对象像内置类型一样运行

比较魔术方法：使用运算符实现对象之间的直观比较，而不是笨拙的方法调用。它们还提供了一种覆盖默认Python行为以进行对象比较的方法（通过引用）
__cmp__(self, other)
__cmp__是比较魔术方法中最基本的。它实际上实现了所有比较运算符（<，==，！=等）的行为，但它可能不会按照您想要的方式执行（例如，如果一个实例是否等于另一个实例由一个标准确定并且一个实例是否大于另一个实例是由其他东西确定的。__cmp__应该返回一个负整数if self < other，zero if self == other和positive if self > other。通常最好定义您需要的每个比较，而不是一次定义它们，但是__cmp__当您需要使用类似标准实现所有比较时，这可以是节省重复和提高清晰度的好方法。
__eq__(self, other)
定义相等运算符的行为==。
__ne__(self, other)
定义不等式运算符的行为!=。
__lt__(self, other)
定义less-than运算符的行为<。
__gt__(self, other)
定义大于运算符的行为>。
__le__(self, other)
定义小于或等于运算符的行为<=。
__ge__(self, other)
定义大于或等于运算符的行为>=。



数字魔术方法：
就像您可以创建类的实例与比较运算符进行比较的方法一样，您可以为数字运算符定义行为
我将数字魔术方法分为5类：一元运算符，普通算术运算符，反射算术运算符，扩充赋值和类型转换。
一元运算符和函数
一元运算符和函数只有一个操作数，例如否定，绝对值等。

__pos__(self)
实现一元正面行为（例如+some_object）
__neg__(self)
实现否定行为（例如-some_object）
__abs__(self)
实现内置abs()函数的行为。(取绝对值)
__invert__(self)
使用~运算符实现反转行为。有关此操作的解释，请参阅Wikipedia关于按位操作的文章。
__round__(self, n)
实现内置round()函数的行为。n是要舍入的小数位数。
__floor__(self)
实现行为math.floor()，即向下舍入到最接近的整数。
__ceil__(self)
实现行为math.ceil()，即舍入到最接近的整数。
__trunc__(self)
实现行为math.trunc()，即截断为整数。


普通算术运算符
现在，我们将介绍典型的二元运算符（以及一个或两个函数）：+， - ，*等。在大多数情况下，这些都是非常不言自明的。

__add__(self, other)
实施添加。
__sub__(self, other)
实现减法。
__mul__(self, other)
实现乘法。
__floordiv__(self, other)
使用//运算符实现整数除法。
__div__(self, other)
使用/运营商实施部门划分。
__truediv__(self, other)
实现真正的分裂。请注意，这仅from __future__ import division在有效时才有效。
__mod__(self, other)
使用%运算符实现模数。
__divmod__(self, other)
使用divmod()内置函数实现长除法的行为。
__pow__
使用**运算符实现指数的行为。
__lshift__(self, other)
使用<<运算符实现左按位移位。
__rshift__(self, other)
使用>>运算符实现右移位。
__and__(self, other)
按位实现并使用&运算符。
__or__(self, other)
按位实现或使用|运算符。
__xor__(self, other)
使用^运算符实现按位xor 。


反射算术运算符：反射的等价物是相同的，除了切换操作数
除了用其他作为第一个操作数和self作为第二个操作执行操作，而不是相反。在大多数情况下，反射操作的结果与其正常的等效操作相同，因此您可能最终定义__radd__为调用__add__等等。

增强分配：Python还有各种各样的魔术方法，允许为增强赋值定义自定义行为。您可能已经熟悉增强赋值，它将“常规”运算符与赋值结合起来。


__iadd__(self, other)
通过赋值实现添加。
__isub__(self, other)
使用赋值实现减法。
__imul__(self, other)
使用赋值实现乘法。
__ifloordiv__(self, other)
使用//=运算符实现赋值的整数除法。
__idiv__(self, other)
使用/=运算符实现分配。
__itruediv__(self, other)
通过赋值实现真正的除法。请注意，这仅from __future__ import division在有效时才有效。
__imod__(self, other)
使用%=运算符实现赋值模数。
__ipow__
使用**=运算符实现赋值的指数的行为。
__ilshift__(self, other)
使用<<=运算符通过赋值实现左按位移位。
__irshift__(self, other)
使用>>=运算符通过赋值实现右移位。
__iand__(self, other)
按位实现并使用&=运算符进行赋值。
__ior__(self, other)
按位实现或使用|=运算符赋值。
__ixor__(self, other)
使用^=运算符使用赋值实现按位xor 。


类型转换魔术方法：
Python还有一系列魔术方法，用于实现内置类型转换函数的行为float()。
__int__(self)
实现类型转换为int。
__long__(self)
实现类型转换为long。
__float__(self)
实现类型转换为float。
__complex__(self)
实现类型转换为复杂。
__oct__(self)
实现类型转换为八进制。
__hex__(self)
实现类型转换为十六进制。
__index__(self)
在切片表达式中使用对象时，实现类型转换为int。如果定义可能在切片中使用的自定义数字类型，则应定义__index__。
__trunc__(self)
调用时math.trunc(self)调用。__trunc__应该将`self truncated的值返回到整数类型（通常是long）。
__coerce__(self, other)
实现混合模式算法的方法。如果无法进行类型转换，__coerce__则应返回 None否则，它应该返回一对（2元组），self并且other操作具有相同的类型。



代表你的课程：
在Python中，您可以在类定义中实现一些方法，以自定义返回类的表示形式的内置函数的行为。

__str__(self)
定义str()在类的实例上调用when的行为。
__repr__(self)
定义repr()在类的实例上调用when的行为。之间的主要区别str()，并repr()在目标受众。repr()旨在产生主要是机器可读的输出（在许多情况下，它甚至可以是有效的Python代码），而str()旨在是人类可读的。
__unicode__(self)
定义unicode()在类的实例上调用when的行为。unicode()就像str()，但它返回一个unicode字符串。要小心：如果客户端调用str()了您的类的实例并且您只定义了__unicode__()它，那么它将无法工作。你应该总是尝试定义__str__()以防万一有人没有使用unicode的奢侈。
__format__(self, formatstr)
定义在新样式字符串格式中使用类实例的行为。例如，"Hello, {0:abc}!".format(a)会导致通话a.__format__("abc")。这对于定义您可能希望提供特殊格式选项的数字或字符串类型非常有用。
__hash__(self)
定义hash()在类的实例上调用when的行为。它必须返回一个整数，其结果用于字典中的快速键比较。请注意，这通常也需要实现__eq__。按照以下规则生活：a == b暗示hash(a) == hash(b)。
__nonzero__(self)
定义bool()在类的实例上调用when的行为。应该返回，True或者False，取决于您是否要考虑实例True或False。
__dir__(self)
定义dir()在类的实例上调用when的行为。此方法应返回用户的属性列表。通常，实现__dir__是不必要的，但如果您重新定义__getattr__或__getattribute__（将在下一节中看到）或以其他方式动态生成属性，则对于类的交互式使用非常重要。
__sizeof__(self)
定义sys.getsizeof()在类的实例上调用when的行为。这应该返回对象的大小，以字节为单位。这对于在C扩展中实现的Python类通常更有用，但它有助于了解它。




控制属性访问：
许多从其他语言进入Python的人抱怨它缺乏对类的真正封装; 也就是说，没有办法用公共getter和setter定义私有属性。这不可能比事实更进一步：它恰好发生了Python通过“魔术”完成大量封装，而不是方法或字段的显式修饰符。看一看：

__getattr__(self, name)
您可以定义用户何时尝试访问不存在的属性（完全或尚未访问）的行为。这对于捕获和重定向常见的拼写错误非常有用，可以提供有关使用弃用属性的警告（如果您愿意，您仍然可以选择计算并返回该属性），或者巧妙地处理AttributeError。
它只在访问不存在的属性时被调用，但是，它不是真正的封装解决方案。（用户访问一个不存在的属性时调用）


__setattr__(self, name, value)：
不像__getattr__，__setattr__是一种封装解决方案。它允许您定义分配给属性的行为，无论该属性是否存在，这意味着您可以为属性值的任何更改定义自定义规则。但是，您必须小心使用方式__setattr__，因为列表末尾的示例将显示。
（设置属性时调用）


__delattr__(self, name)：
这与__setattr__删除属性而不是设置属性完全相同。__setattr__为了防止无限递归（del self.name在执行中调用__delattr__会导致无限递归），也需要采取相同的预防措施。（删除一个属性时调用）


__getattribute__(self, name)：
这一切后，__getattribute__适合在相当不错，其同伴__setattr__和__delattr__。但是，我不建议你使用它。
__getattribute__只能用于新式类（所有类在最新版本的Python中都是新式的，而在旧版本中，您可以通过子类化使类成为新式object。
它允许您为属性的值定义规则它遇到了一些类似的无限递归问题，就像它的犯罪伙伴一样（这次你调用基类的__getattribute__方法来防止这种情况）。它还主要消除了对它的需要__getattr__，当它__getattribute__被实现时，只有被调用才会被调用。
被明确地称为或AttributeError被提出来了。可以使用这个方法（毕竟，这是你的选择），但我不推荐它，因为它有一个小的用例（我们需要特殊的行为来检索一个值而不是分配给它），因为实现无bug是非常困难的。（访问存在的属性时调用）


制定自定义序列：有许多方法可以让Python类表现得像内置序列（dict，tuple，list，str，等

协议有点类似于其他语言中的接口，因为它们为您提供了一组必须定义的方法。但是，在Python中，协议是完全非正式的，不需要显式声明来实现。相反，它们更像是指导方针。

首先，有用于定义不可变容器的协议：要创建一个不可变容器，您只需要定义__len__和__getitem__（稍后会详细介绍）。可变容器协议需要不可变容器所需的所有内容__setitem__和__delitem__。最后，如果您希望对象可迭代，则必须定义__iter__，返回迭代器。该迭代器必须符合迭代器协议，该协议要求迭代器具有调用__iter__（返回自身）和的方法next。


__len__(self)
返回容器的长度。不可变容器和可变容器的协议的一部分。
__getitem__(self, key)
使用表示法定义访问项目时的行为self[key]。这也是可变和不可变容器协议的一部分。它还应该引发适当的例外：TypeError如果密钥的类型错误并且密钥KeyError没有相应的值。（获取容器中指定元素的行为）
__setitem__(self, key, value)
使用表示法定义项目分配时的行为self[nkey] = value。这是可变容器协议的一部分。同样，你应该提出KeyError并TypeError在适当情况下。（设置容器中指定元素的行为）
__delitem__(self, key)
定义项目被删除时的行为（例如del self[key]）。这只是可变容器协议的一部分。使用无效密钥时，必须引发相应的异常。
__iter__(self)
应该返回容器的迭代器。迭代器在许多上下文中返回，最明显的是iter()内置函数以及使用表单循环容器时for x in container:。迭代器是它们自己的对象，它们也必须定义一个__iter__返回的方法self。（定义迭代器中元素的行为）
__reversed__(self)
被调用以实现reversed()内置函数的行为。应返回序列的反转版本。只有在序列类被排序时才实现它，例如list或tuple。
__contains__(self, item)
__contains__使用in和定义成员资格测试的行为not in。你问，为什么不是序列协议的这一部分？因为当__contains__没有定义时，Python只是迭代序列并返回True它遇到它正在寻找的项目。（成员运算符in/ not in的行为）
__missing__(self, key)
__missing__用于子类dict。它定义了每当访问一个字典中不存在的密钥时的行为（例如，如果我有一个字典，d并且说d["george"]什么时候"george"不是字典中的密钥，d.__missing__("george")则会被调用）。



反射：
您还可以通过定义魔术方法来控制使用内置函数isinstance()和issubclass()行为的反射方式。神奇的方法是：

__instancecheck__(self, instance)
检查实例是否是您定义的类的实例（例如isinstance(instance, class)，
__subclasscheck__(self, subclass)
检查一个类是否是您定义的类的子类（例如issubclass(subclass, class)）。


可调用对象：
Python中一种特殊的魔术方法允许类的实例表现得就像它们是函数一样，这样你就可以“调用”它们，将它们传递给以函数作为参数的函数，依此类推。这是另一个强大的便利功能，使Python中的编程更加甜蜜。

__call__(self, [args...])
允许将类的实例作为函数调用。从本质上讲，这意味着它x()是相同的x.__call__()。注意，__call__采用可变数量的参数; 这意味着你可以__call__像任何其他函数一样定义，无论你想要多少参数。


上下文管理器
在Python 2.5中，Python中引入了一个新的关键字以及一种新的代码重用方法：with语句。上下文管理器的概念在Python中并不是新的（它之前是作为库的一部分实现的），但直到PEP 343被接受才能实现作为一流语言构造的状态。
当对象的创建用with语句包装时，上下文管理器允许对对象进行设置和清理操作。上下文管理器的行为由两种魔术方法决定：

__enter__(self)
定义上下文管理器在with语句创建的块的开头应该执行的操作。注意，返回值__enter__被绑定到目标的的with陈述，或之后的名称as。
__exit__(self, exception_type, exception_value, traceback)
定义上下文管理器在块执行（或终止）后应该执行的操作。它可以用于处理异常，执行清理，或者在块中的操作之后立即执行某些操作。如果块成功执行，exception_type，exception_value，和traceback会None。否则，您可以选择处理异常或让用户处理它; 如果你想处理它，请确保在完成所有操作后__exit__返回True。如果您不希望上下文管理器处理异常，那就让它发生。

请注意，Python标准库包含一个包含上下文管理器的模块contextlibcontextlib.closing()，它执行大致相同的操作（没有处理对象没有close()方法的情况）。



构建描述符对象：
描述符是一类，当通过获取，设置或删除访问时，也可以改变其他对象。

要成为一个描述符，类必须有至少一个__get__，__set__和__delete__实施。我们来看看那些神奇的方法：

__get__(self, instance, owner)
定义检索描述符值的行为。instance是所有者对象的实例。owner是所有者类本身。
__set__(self, instance, value)
定义描述符值更改时的行为。instance是所有者类的实例，value是设置描述符的值。
__delete__(self, instance)
定义删除描述符值的行为。instance是所有者对象的实例。

仿形
有时，特别是在处理可变对象时，您希望能够复制对象并进行更改，而不会影响您从中复制的内容。
__copy__(self)
copy.copy()为您的类的实例定义行为。copy.copy()返回对象的浅表副本 - 这意味着，虽然实例本身是一个新实例，但它的所有数据都被引用 - 即，对象本身被复制，但其数据仍被引用（因此更改为数据）在浅拷贝中可能会导致原始的变化）。
__deepcopy__(self, memodict={})
copy.deepcopy()为您的类的实例定义行为。copy.deepcopy()返回一个深拷贝你的对象-对象和它的数据都被复制。memodict是以前复制的对象的缓存 - 这可以优化复制并在复制递归数据结构时防止无限递归。如果要深度复制单个属性，请copy.deepcopy()使用memodict第一个参数调用该属性。




Pickling是Python数据结构的序列化过程，当您需要存储对象并稍后检索它时（通常用于缓存），它可以非常有用。

pickle协议有四个可选方法供Python对象自定义它们的行为方式（对于C扩展，它有点不同，但这不在我们的范围内）：

__getinitargs__(self)
如果你希望__init__在你的类被打开时被调用，你可以定义__getinitargs__，它应该返回你想要传递给的参数的元组 __init__。请注意，此方法仅适用于旧式类。
__getnewargs__(self)
对于新式类，您可以影响__new__在unpickling时传递给哪些参数。此方法还应返回一个参数元组，然后传递给它__new__。
__getstate__(self)
__dict__您可以返回在对象被pickle时存储的自定义状态，而不是存储对象的属性。__setstate__当对象被打开时，将使用该状态。
__setstate__(self, state)
当对象被取消标记时，如果__setstate__定义了对象的状态将被传递给它而不是直接应用于对象的状态__dict__。这与__getstate__以下内容密切相关：当两者都被定义时，您可以根据需要表示对象的酸洗状态。
__reduce__(self)
在定义扩展类型（即使用Python的C API实现的类型）时，你必须告诉Python如果你想让它们腌制它们如何腌制它们。__reduce__()当定义它的对象被pickle时调用。它可以返回一个表示Python将查找和pickle的全局名称的字符串，或者一个元组。元组包含2到5个元素：一个可调用对象，用于重新创建对象，一个可调用对象的参数元组，要传递给的状态__setstate__（可选），一个迭代器，产生要被pickle的列表项（可选），和一个迭代器，产生要被pickle的字典项（可选）。
__reduce_ex__(self)
__reduce_ex__存在兼容性。如果定义了，__reduce_ex__将__reduce__在酸洗时调用。__reduce__也可以定义不支持的旧版酸洗API __reduce_ex__。




魔术方法	当它被调用时（例子）	说明
__new__(cls [,...])	instance = MyClass(arg1, arg2)	__new__ 在实例创建时调用
__init__(self [,...])	instance = MyClass(arg1, arg2)	__init__ 在实例创建时调用
__cmp__(self, other)	self == other，self > other等等。	要求任何比较
__pos__(self)	+self	一元加号
__neg__(self)	-self	一元减号
__invert__(self)	~self	按位反转
__index__(self)	x[self]	将对象用作索引时的转换
__nonzero__(self)	bool(self)	对象的布尔值
__getattr__(self, name)	self.name # name doesn't exist	访问不存在的属性
__setattr__(self, name, val)	self.name = val	分配给属性
__delattr__(self, name)	del self.name	删除属性
__getattribute__(self, name)	self.name	访问任何属性
__getitem__(self, key)	self[key]	使用索引访问项目
__setitem__(self, key, val)	self[key] = val	使用索引分配项目
__delitem__(self, key)	del self[key]	使用索引删除项目
__iter__(self)	for x in self	迭代
__contains__(self, value)	value in self， value not in self	使用会员资格测试 in
__call__(self [,...])	self(args)	“呼叫”一个实例
__enter__(self)	with self as x:	with 陈述背景管理者
__exit__(self, exc, val, trace)	with self as x:	with 陈述背景管理者
__getstate__(self)	pickle.dump(pkl_file, self)	酸洗
__setstate__(self)	data = pickle.load(pkl_file)	酸洗


在这里，我们记录了Python 3在其对象模型方面与2.x不同的几个主要位置：

由于字符串和Unicode之间的区别已经与Python 3中已经做了，__unicode__消失了，__bytes__（其行为类似于__str__和__unicode__2.7）存在一个新的内置构建字节数组。
由于在Python 3中除法默认为真正的除法，因此在Python 3 __div__中已经消失了
__coerce__ 由于其他魔术方法和混乱行为的冗余而消失了
__cmp__ 由于其他魔术方法的冗余而消失了
__nonzero__ 已重命名为 __bool__




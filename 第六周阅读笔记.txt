第一个链接：
只需将@simple_decorator(一个装饰器)应用于你的装饰者即可，它将自动保留docstring和函数属性的函数它被应用了。
sinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。
sys._getframe(1).f_locals：本地名字空间
在Python中，property()是一个内置函数，用于创建和返回一个property对象。该函数的签名为：
property(fget=None, fset=None, fdel=None, doc=None)
这里，fget是一个获取属性值的函数，fset是一个设置属性值的函数，fdel是一个删除属性的函数，doc是一个字符串（类似于注释）。从函数实现上看，这些函数参数都是可选的。所以，可以按照如下的方式简单的创建一个property对象。
Property对象有三个方法，getter(), setter()和delete()，用来在对象创建后设置fget，fset和fdel。
 @apply  # doesn't exist in Python 3


内建函数：
 # Python 2

# Python 3
     import builtins     import __builtin__ as builtins

radians() 方法将角度转换为弧度。
collections是Python内建的一个集合模块,提供了许多有用的集合类。

memoize：是记忆函数每次运行的结果，这样当递归函数每次递归时，若已经计算过子函数，就直接从记忆中的结果获取，避免重复计算。

备用memoize作为嵌套函数：这是一个可用于函数，方法或类的memoizing函数，并公开公开缓存。

备用memoize作为dict子类

在执行之间存储缓存的备用memoize:
pickle: 用于python特有的类型和python的数据类型间进行转换
inspect模块主要提供了四种用处：

(1).对是否是模块，框架，函数等进行类型检查。

(2).获取源码

(3).获取类或函数的参数的信息

(4).解析堆栈

import unicodedata:字符数据库



用@Memorize装饰的函数缓存它的返回每次调用它的价值。如果函数被调用稍后使用相同的参数，缓存的值为返回（该函数未重新评估）。缓存是
存储为当前目录中的.cache文件以供重用在未来的执行中。如果Python文件包含装饰功能自上次运行以来已更新，删除当前缓存并创建新缓存（如果
函数的行为发生了变化）。

Python os.path.abspath(__file__) 获取脚本完整路径

重试
调用一个返回True / False的函数来表示成功或失败。失败时，请等待，然后再次尝试该功能。在重复故障时，在每次连续尝试之间等待更长时间
如果装饰器用完了尝试，那么它会放弃并返回False，但你可以轻易地引发一些异常。
delay以秒为单位设置初始延迟，backoff设置的因子，每次失败后延迟应该延长。退避必须大于1，否则它不是真正的退避。尝试必须至少为0，并且延迟
大于0.

使用可选参数创建装饰器（只有一个缺点：包装器检查单个函数或类的参数。为避免错误行为，您可以使用关键字参数而不是位置）

Decorator返回一个保持返回函数的函数直到提供所有参数; 然后原来的功能是评估。

Decorator有助于控制程序的哪些方面进行调试在每个功能的基础上。方面列为参数列表。它不会减慢不应调试的功能。

Generating Deprecation Warnings：这是一个装饰器，可用于标记功能已弃用。它会导致发出警告当使用该功能时。
import warnings：引入警告

Ignoring Deprecation Warnings：这是一个装饰器，可以用来忽略弃用警告发生在一个函数中。

Enable/Disable Decorators:启用/禁用装饰器
func.func_code.co_varnames:COVEARVENS是一个包含局部变量名称的元组（从参数名开始）；

Pre-/Post-Conditions:前置/后置条件





线追踪个别功能
我从跟踪模块拼凑了这个。它允许您装饰各个函数，以便跟踪它们的行。我认为它比运行跟踪模块稍微小一点，并尝试使用排除功能削减其跟踪的内容

同步：同步给定锁上的两个（或更多）函数。

类型执行（接受/退货）：为函数参数和返回值提供不同程度的类型强制。

通过可以指定三种执行程度中的一种 装饰器的'debug'关键字参数：
0  - 无：无类型检查。装饰者禁用。
＃！python 
1  MEDIUM：向stderr打印警告消息。（默认）
2  -  STRONG：使用消息引发TypeError。如果'debug'未传递给装饰器，则使用默认级别。


CGI方法包装器
处理从CGI方法返回的页面顶部和底部的HTML样板。适用于cgi模块。现在你的请求处理程序可以输出有趣的HTML，并让装饰器处理所有顶部和底部的混乱。
(注意：异常处理程序会占用所有异常，这在CGI中没有大的损失，因为程序在其单独的子进程中运行。至少在这里，异常内容将被写入输出页面。）


国家机器实施:
用装饰器来促进Python中的状态机的实现。装饰器用于指定哪些方法是类的事件处理程序。
定义了一个类MyMachine，它是一个状态机。可以实例化该类的多个实例，每个实例保持其自己的状态。一个类也可能有多个状态。在这里，我使用了gstate和tstate。

类似C ++ / Java关键字的函数装饰器:
@abstractMethod，@ deprecatedMethod，@ privateMethod，@ protectedMethod，@ raises，@ parameterTypes，@ returnType
不同的装饰形式
以下各方之间存在差异：

装饰者没有参数
装饰员与参数
具有包装类实例感知的装饰器

未实现的功能替换:允许您通过将默认参数指定为装饰器的参数来测试开发环境中未实现的代码（或者您可以将其保留为指定None以进行返回。
LogPrinter类，用于模拟文件对象和日志的Log打印机类
无论它被发送到信息级别的记录器对象。

python assert断言是声明其布尔值必须为真的判定，如果发生异常就说明表达示为假。可以理解assert断言语句为raise-if-not，用来测试表示式，其返回值为假，就会触发异常。

使用实例的类方法装饰器:
在装饰类方法时，装饰器接收尚未绑定到实例的函数。装饰器不能在调用它的实例上做任何事情，除非它实际上是描述符。


另一个重试装饰者:这是另一个装饰器，用于使函数重试一定次数。
特征：
适用于通过引发异常来表示失败的任何函数（IE几乎任何函数）
支持重试延迟和退避
用户可以指定重试捕获的异常。例如，网络代码可能会在通信困难时引发SocketError，而任何其他异常都可能表示代码中存在错误。
挂钩进行自定义日志记录
 如果它增加装饰器将调用该函数达max_tries次 例外。默认情况下，它捕获Exception类和子类的实例。
除了最致命的错误之外，这将会恢复。你可以指定带有'exceptions'参数的异常类的自定义元组; 在
只有在提升指定的之一时才会重试该函数例外。另外，您可以指定一个将在之前调用的钩子函数 ,重试剩余的尝试次数和异常实例; 
这主要是为了给个机会记录失败。如果没有重试，则在失败后不会调用Hook。


使用指定的记录器（或默认）记录装饰器：
此装饰器将使用指定的记录器记录您的功能的入口和出口点，或者它默认为您的功能的模块名称记录器。


Lazy Thunkify
这个装饰器将导致任何函数，而不是运行其代码，启动一个线程来运行代码，返回一个等待函数完成的thunk（没有args的函数）并返回值（或引发异常）。
使函数立即返回无参数的函数，当调用时，等待结果，它将开始在另一个线程中处理。


生成器函数的聚合装饰器：这可能是整个装饰家族。目标是将聚合函数应用于生成器函数的迭代结果。

功能超时：
在一种情况下，一个函数是使用正则表达式从长字符串中提取URI，有时它会在Python regexp引擎中遇到错误，并且需要几分钟而不是几毫秒。
最好的解决方案是使用警报信号安装超时并简单地中止处理


收集装饰函数引起的数据差异
它调用用户函数来在装饰函数运行之前和之后收集一些数据。为了计算差异，它调用差值计算器用户函数。


msgstr返回在修饰函数之前和之后收集的数据的差异，加上修饰函数的原始返回值。返回类型：字典。







第二个链接：
Python支持迭代容器的概念。这是使用两种不同的方法实现的; 这些用于允许用户定义的类支持迭代。

container.__iter__（）
返回一个迭代器对象。该对象需要支持下面描述的迭代器协议。如果容器支持不同类型的迭代，则可以提供其他方法来专门请求这些迭代类型的迭代器。（支持多种迭代形式的对象的示例是支持广度优先和深度优先遍历的树结构。）此方法对应tp_iter于Python / C API中Python对象的类型结构的 槽。

迭代器对象本身需要支持以下两个方法，它们共同构成迭代器协议：

iterator.__iter__（）
返回迭代器对象本身。这是允许容器和迭代器与for和in语句一起使用所必需的。此方法对应tp_iter于Python / C API中Python对象的类型结构的槽。

iterator.next（）
从容器中返回下一个项目。如果没有其他项目，请提出StopIteration异常。此方法对应tp_iternext于Python / C API中Python对象的类型结构的 槽。

Python定义了几个迭代器对象，以支持对一般和特定序列类型，字典和其他更专业的表单的迭代。除了迭代器协议的实现之外，特定类型并不重要。

协议的目的是一旦迭代器的next()方法提出StopIteration，它将继续在后续调用中这样做。


Python的生成器提供了一种实现迭代器协议的便捷方式。如果容器对象的__iter__()方法是作为生成器实现的，它将自动返回提供__iter__()和 next()方法的迭代器对象（技术上，生成器对象）。






第三个链接：
当复杂函数的逻辑被分成几个本身就是函数的自包含步骤时，这些函数就被称为辅助函数或子例程。
Python中的子程序由main函数调用，它负责协调这些子程序的使用。子程序有单个入口点。

协同程序是子程序的泛化。它们用于协作式多任务处理，其中进程周期性地或在空闲时自愿地产生（放弃）控制，以便能够同时运行多个应用程序。协程和子程序之间的区别是：

1.与子例程不同，协同程序有许多用于挂起和恢复执行的入口点。协程可以暂停其执行并将控制转移到其他协程，并可以从它停止的点恢复执行。
2.与子程序不同，没有主要功能可以按特定顺序调用协同程序并协调结果。协同程序是合作的，这意味着它们连接在一起形成管道。
一个协程可能会消耗输入数据并将其发送给处理它的其他人。最后，可能会有一个协程来显示结果。


在线程的情况下，它是根据调度程序在线程之间切换的操作系统（或运行时环境）。在协同程序的情况下，它是程序员和编程语言决定何时切换协同程序。
协同程序通过暂停和恢复设定点协同工作。


在Python中，协程类似于生成器，但几乎没有额外的方法，我们使用yield语句的方式略有变化。协同程序生成迭代的数据，而协同程序也可以使用数据。


在Python 2.5中：line =（yield）
我们发送给协程的任何值都被捕获并通过（yield）表达式返回。
可以通过send（）方法将值发送到协同程序。

协程的执行类似于发生器。当我们调用coroutine时没有任何反应，它只在响应next（）和send（）方法时运行。


协程可能无限期运行，使用关闭协程close（）方法。当协同程序关闭时，它会生成GeneratorExit异常，可以通过常规方式捕获。关闭协同程序后，如果我们尝试发送值，它将引发StopIteration异常。



协同程序可用于设置管道。我们可以使用send（）方法将协程链接在一起并通过管道推送数据。管道需要：

导出整个管道的初始源（生产者）。制片人通常不是协程，它只是一种简单的方法。
一个水槽，它是管道的终点。接收器可以收集所有数据并显示它。